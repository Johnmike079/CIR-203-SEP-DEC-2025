QUESTION 2.

transactions = np.array([
    [1200, 1500, 1300, 1600, 1700, 1800],  
    [2000, 2100, 2200, 2300, 2400, 2500],  
    [1700, 1600, 1500, 1400, 1300, 1200],  
    [1000, 1100, 1200, 1300, 1400, 1500]   
])
print("Transaction Volumes (4 branches × 6 months):\n", transactions)

total_per_branch = np.sum(transactions, axis=1)
print("\nTotal transactions per branch:", total_per_branch)

highest_branch = np.argmax(total_per_branch) + 1  
print("\nBranch with highest transactions: Branch", highest_branch)

average_monthly = np.mean(transactions, axis=0)
print("\nAverage monthly transaction volume across all branches:", average_monthly)

reshaped_array = transactions.reshape(3, 8)
print("\nReshaped Array (3 × 8):\n", reshaped_array)


Reshaping does NOT change the data, only how it is organized in memory.
Originally, data was structured as 4 branches × 6 months.
After reshaping to 3 × 8, the meaning of rows/columns is lost
(e.g., rows no longer directly represent branches, and columns no longer directly represent months).
So, reshaping is useful for mathematical manipulation, but context/interpretation is lost.




QUESTION 2.

routes = [
    "Nairobi-Mombasa",
    "Kisumu-Nairobi",
    "Nakuru-Eldoret",
    "Nairobi-Naivasha",
    "Eldoret-Kakamega",
    "Kisumu-Busia",
    "Nairobi-Kitengela",
    "Machakos-Nairobi"
     ]
print("Initial Routes:", routes)
routes.remove("Kisumu-Busia")
print("\nAfter adding & removing:", routes)

routes.sort()
print("\nSorted Routes:", routes)

routes.reverse()
print("\nReversed Routes:", routes)

count_N = sum(route.startswith("N") for route in routes)
print("\nNumber of routes starting with 'N':", count_N)

long_routes = [route for route in routes if len(route) > 10]
print("\nRoutes longer than 10 characters:", long_routes)


QUESTION 3.

patient = ("John", 45, "120/80", 72)
print("Patient Record:", patient)

print("\nPatient Age:", patient[1])
print("Patient Heart Rate:", patient[3])


Why tuples are suitable:
Tuples are immutable, meaning once created, data cannot be accidentally modified.
This ensures patient vitals remain consistent and tamper-proof,
which is important for maintaining accurate medical records.


patient_list = list(patient)
patient_list[3] = 78 
patient = tuple(patient_list)
print("\nUpdated Patient Record:", patient)

patients = (
    ("John", 45, "120/80", 78),
    ("Mary", 38, "110/70", 75),
    ("James", 60, "130/85", 82),
    ("Linda", 29, "115/75", 68),
    ("Peter", 50, "140/90", 88)
                    )

                    
names = [p[0] for p in patients]
print("\nAll Patient Names:", names)



QUESTION 4.

inventory = {
    "Laptop": 15,
    "Headphones": 8,
    "Mouse": 25,
    "Keyboard": 12,
    "USB_Cable": 5
}

inventory["Monitor"] = 20
inventory["Headphones"] = 10

def low_stock_products(stock_dict):
    low_items = []
    for product, qty in stock_dict.items():
        if qty < 10:
            low_items.append(product)
    return low_items


low_items = low_stock_products(inventory)
print("Products with low stock (<10):", low_items)

del inventory["USB_Cable"]
print("Updated inventory after deletion:", inventory)

print("\nProduct List:")
for product, qty in inventory.items():
    print(f"{product} : {qty}")
